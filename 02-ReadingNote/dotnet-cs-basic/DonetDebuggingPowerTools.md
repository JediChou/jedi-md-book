# .NET Debugging Power Tools

## 1 Visual Studio 2013 Diagnostics for .NET

### 1.1 Introduction

* Focus is on .NET Diagnostics improvements
* Two sets of experiences for two different scenarios
  * Debugging Tools for Windows
  * Visual Studio Diagnostics
* Visual Studio 2013 bridges gap by focusing on developer-operations
* Contains a slew of new features
  * Diagnostics hub
  * Enhanced dump analysis
  * 64bit edit and continue support
  * .NET return value inspection
  * Async debugging

### 1.2 Diagnostics Hub

* One stop shop for all performance and diagnostics activities
* Only shows the tools applicable to the application

* Action
  * DEBUG -> Performance and Diagnostics
  * CPU Sampling, Energy Consumption, XAML UI Responsiveness
  * Other Applicable Tools contains
    * HTML UI Responsiveness
    * JavaScript Function Timing
    * JavaScript Memory
    * Performance Wizard

* Jedi Question: Why should save a diagnostics session file?
* Jedi Question: How to start a remote diagnostics action?
* Jedi Question: What differents between turning with diagnotics?

### 1.3 Enhanced Dump Analysis

* Opens crash dumps generated by Task Manager regardless of bitness
* .NET memory analysis
  * What types are present on the heap
  * Reference chain to the problematic types
  * Comparing dumps

* Action: Select a program and create a dump file at Windows Task Manager.
* Action: Open dump file with Visual Studio 2013
  * Author show you how to check program modules
* Action: Choice Debug Managed Memory Option, it entered into Heap views.
* Action: Create another dump file.
* Action: And compare two dump files with Visual Studio 2013.
  * Check differents (View setting have filtered some object types).

* Jedi: The author create a memory leak console program.
* Jedi: What is the start command at Windows CMD environment?
* Jedi: How operate those action with Visual Studio Code?
* 16:08 PM

### 1.3 64-bit Edit and Continue

* Change code with debugging
* Eliminates the need for stop and start debugging
* Has been available in 32-bit for quite some time
* Now works on 64-bit
  * Requires .NET 4.5.1
* Can be explicitly enabled/disabled

* Action
  * During Web Form debugging, you can't change variables.
  * But if you set Debuggers option, you can change variables.
    * Right click project node.
    * Select properties
    * Select Web Tab
    * And set Debuggers option (enable Enable Edit and Continue).

### 1.4 .NET Return Value Inspection

* Previously, no convenient way to monitor return values
* Now, method return values can be inspected in the Auto window
  * Pseudo variables $ReturnValue

### 1.5 Async Debugging

* Async is very popular pattern in Store applicaitons
  * Used to be painful to debug

* Require Visual Studio 2013 installed on Windows 8.1

* Enhancements in Visual Studio 2013 makes the async debugging experience much nicer
  * Callstacks show [Async Call] frame
  * Tasks window shows all async operations and their status

* Action
  * Click DEBUG,Windows,Tasks.
  * You can view awaiting or active task status.

* 16:34 PM

### 1.6 Summary

* Lots of existing new diagnostic features in Visual Studio 2013
  * Diagnostics hub
  * Enhanced dump analysis
  * 64bit edit and continue support
  * .NET return value inspection
  * Async debugging

* 16:36

## 2 .NET 4.5(.x) Garbage Collection

### 2.1 .NET 4.5(.x) Garbage Collection

* Several enhancements have been made to the CLR GC since 4.0
  * Background GC now available (4.5)
  * Server SustainedLowLatency (4.5)
  * X64 large object support (4.5)
    * Free lists (4.5)
    * Heap balancing (4.5)
    * Compaction (4.5.1)
  * SOS DumpHeap command
    * New -live and -dead switches

### 2.2 Background GC (4.5)

* Already available in 4.0 workstation
* Now available in 4.5 server
* Off loads generation 2 GC's to background GC threads
  * Does not require pausing user threads
  * A generation 0 and 1 collection will suspend user and background GC threads

* 16:46 PM

### 2.3 SustainedLowLatency (4.5)

* Full blocking GC introduces possible pauses
* May not be optimal for certain applications
* SustainedLowLatency avoids full blocking GC's
  * Adequate memory must be present on the machine
  * May still occur if machine is low on memory or GC.Collect is called
  * Can be turned on using GCSetting.LatencyMode=GCLatencyMode.SustainedLowLatency

* 2019.11.23 16:51 PM

### 2.4 X64 Large Object Support (4.5)

* Previously, large objects (>2GB) could not be created
  * 64-bit data intensive application suffered (commonly large arrays)

* Limitation is now lifted on 64-bit apps
  * However, limitation stll exists on 32-bit

* Enable using gcAllowVeryLargeObjects option

* Action: Add configure parameter to App.config.

```xml
<runtime>
  <gcAllowVeryLargeObjects enabled="true"/>
</rumtime>
```

* Action: This option must be under x64 mode. If you choice x86 mode OS still give a Memory leak error message.

* 2019.11.23 16:59 PM

### 2.5 Large Object Heap - Free Lists (4.5)

* Large object heap utilizes free lists to optimize space
* Prior to 4.5 free lists were not used optimally
  * Once a block was deemed as not capable of satisfying an allocation it would not be revisited for quite some time

* Jedi: 2019.12.21 17:47

### 2.6 Large Object Heap - Heap Balancing (4.5)

* Server has one heap per logical processor
* When a heap is full, a GC is triggered
  * Allocation pattern causing a particular heap to be used heavily
    * For example, thread allocating more memory than other work threads
  * Source of the problem - the large object heap was not balanced
* Large object heap is now balanced resulting in less GC's as a result
  * In turn - reduces time spent in GC

* There is a big demo for Heap Balancing between .NET 3.5 with .NET 4.5

```c#

class Program
{
  public static void Main(string[] args)
  {

  }
}

```

* Jedi: ntsd.exe，这是个什么玩意？
* Jedi: 看到 00:05:36 h
