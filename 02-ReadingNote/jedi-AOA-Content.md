# 汇编语言

## 第1章 进入汇编语言的世界

* 1.1 本章概述
* 1.2 HLA程序的结构
* 1.3 运行第一个HLA程序
* 1.4 基本HLA数据生命
* 1.5 布尔值
* 1.6 字符值
* 1.7 Intel 80x86处理器简介
* 1.8 基本的机器指令
* 1.9 基本的HLA控制结构
  * 1.9.1 HLA语句中的布尔表达式
  * 1.9.2 HLA的IF..THEN..ELSE, IF..ELSE..ENDIF语句
  * 1.9.3 布尔表达式中的逻辑与、逻辑或以及逻辑非
  * 1.9.4 WHILE..ENDWHILE语句
  * 1.9.5 FOR .. ENDFOR语句
  * 1.9.6 REPEAT..UNTIL语句
  * 1.9.7 BREAK和BREAKIF语句
  * 1.9.8 FOREVER..ENDFOR语句
  * 1.9.9 TRY..EXCEPTION..ENDTRY语句

* 1.10 HLA标准库入门
  * 1.10.1 STDIO模块中的预定义常量
  * 1.10.2 标准输入与标准输出
  * 1.10.3 stdout.newln例程
  * 1.10.4 stdout.putiX例程
  * 1.10.5 stdout.putiXSize例程
  * 1.10.6 stdout.put例程
  * 1.10.7 stdin.getc例程
  * 1.10.8 stdin.getiX例程
  * 1.10.9 stdin.readLn与stdin.flushInput例程
  * 1.10.10 stdin.get例程

* 1.11 关于TRY..ENDTRY的其他细节
  * 1.11.1 TRY..ENDTRY嵌套语句
  * 1.11.2 TRY..ENDTRY语句中不受保护的子句
  * 1.11.3 TRY..ENDTRY语句中的ANYEXCEPTION子句
  * 1.11.4 寄存器与TRY..ENDTRY语句
* 1.12 高级汇编语言与低级汇编语言的比较
* 1.13 更多信息

## 第2章 数据表示

* 2.1 本章概述
* 2.2 数字系统
  * 2.2.1 回顾十进制系统
  * 2.2.2 二进制数字系统
  * 2.2.3 二进制格式

* 2.3 十六进制数字系统
* 2.4 数据结构
  * 2.4.1 位
  * 2.4.2 半字节
  * 2.4.3 字节
  * 2.4.4 字
  * 2.4.5 双字
  * 2.4.6 四字与长字

* 2.5 二进制数与十六进制的算术运算
* 2.6 关于数字及其表示法
* 2.7 位逻辑运算
* 2.8 二进制数和位串的逻辑运算
* 2.9 有符号数和无符号数
* 2.10 符号扩展、零扩展、压缩和饱和
* 2.11 移位和循环移位
* 2.12 位域和压缩数据

* 2.13 浮点运算简介
  * 2.13.1 IEEE浮点格式
  * 2.13.2 HLA为浮点数值提供的支持

* 2.14 BCD数据表示
* 2.15 字符
  * 2.15.1 ASCII字符译码
  * 2.15.2 HLA对ASCII字符提供的支持
* 2.16 Unicode字符集
* 2.17 更多信息

## 第3章 存储器的访问与结构

* 3.1 本章概述
* 3.2 80x86的寻址方式
  * 3.2.1 80x86寄存器寻址方式
  * 3.2.2 80x86的32位存储器寻址方式

* 3.3 运行时存储器的结构
  * 3.3.1 代码段
  * 3.3.2 静态段
  * 3.3.3 只读数据段
  * 3.3.4 存储段
  * 3.3.5 @NOSTORAGE属性
  * 3.3.6 Var段
  * 3.3.7 程序中声明段的结构

* 3.4 HLA如何为变量分配内存
* 3.5 HLA对数据对齐的支持
* 3.6 地址表达式
* 3.7 类型强制转换
* 3.8 寄存器类型强制转换

* 3.9 栈段与PUSH及POP指令
  * 3.9.1 基本的PUSH指令
  * 3.9.2 基本的POP指令
  * 3.9.3 用PUSH和POP指令来保护寄存器
  * 3.9.4 栈的LIFO数据结构
  * 3.9.5 其他的PUSH和POP指令
  * 3.9.6 不使用出栈而从栈内移除数据
  * 3.9.7 访问已入栈而未出栈的数据

* 3.10 动态内存分配和堆段
* 3.11 INC和DEC指令
* 3.12 获取存储器对象的地址
* 3.13 更多信息

## 第4章 常量、变量与数据类型

* 4.1 本章概述
* 4.2 一些额外的指令：INTMUL、BOUND、INTO
* 4.3 TBYTE数据类型
* 4.4 HLA常量和数值声明
* 4.4.1 常量类型
* 4.4.2 字符串和字符字面常量
* 4.4.3 CONST段中的字符串常量与文本常量
* 4.4.4 常量表达式
* 4.4.5 HLA程序中的多个CONST段以及它们的顺序
* 4.4.6 HLA的VAL段
* 4.4.7 在程序中的任意位置修改VAL对象
* 4.5 HLA的TYPE段
* 4.6 ENUM和HLA枚举数据类型
* 4.7 指针数据类型
* 4.7.1 在汇编语言中使用指针
* 4.7.2 在HLA中声明指针
* 4.7.3 指针常量和指针常量表达式
* 4.7.4 指针变量和动态内存分配
* 4.7.5 指针的常见问题
* 4.8 HLA标准库CHARS.HHF模型
* 4.9 复合数据类型
* 4.10 字符串
* 4.11 HLA字符串
* 4.12 访问字符串中的某个字符
* 4.13 HLA字符串模块和其他与字符串相关的例程
* 4.14 存储器内转换
* 4.15 字符集
* 4.16 在HLA中实现字符集
* 4.17 HLA字符集常量和字符集表达式
* 4.18 HLA HLL布尔表达式中的IN操作符
* 4.19 HLA标准库对字符集的支持
* 4.20 在HLA程序中使用字符集
* 4.21 数组
* 4.22 在HLA程序中声明数组
* 4.23 HLA数组常量
* 4.24 访问一维数组的元素
* 4.25 多维数组
* 4.25.1 以行为主排列
* 4.25.2 以列为主排列
* 4.26 多维数组的存储空间分配
* 4.27 汇编语言中多维数组元素的访问
* 4.28 大数组和MASM（只适用于Windows程序员）
* 4.29 记录
* 4.30 记录常量
* 4.31 记录数组
* 4.32 数组/记录作为记录字段
* 4.33 控制记录中的字段偏移量
* 4.34 对齐记录中的字段
* 4.35 记录指针
* 4.36 联合
* 4.37 匿名联合
* 4.38 变量类型
* 4.39 联合常量
* 4.40 命名空间
* 4.41 汇编语言中的动态数组
* 4.42 HLA标准库数组支持
* 4.43 更多信息

## 第5章 过程与单元

* 5.1 本章概述
* 5.2 过程
* 5.3 机器状态的保存
* 5.4 过程的提前返回
* 5.5 局部变量
* 5.6 其他局部和全局符合类型
* 5.7 参数
* 5.7.1 值传递
* 5.7.2 引用传递
* 5.8 函数和函数的结果
* 5.8.1 返回函数结果
* 5.8.2 HLA的指令合成
* 5.8.3 HLA过程和@RETURNS选项
* 5.9 递归
* 5.10 过程的向前引用
* 5.11 过程的底层实现与CALL指令
* 5.12 过程与堆栈
* 5.13 活动记录
* 5.14 标准入口序列
* 5.15 标准出口序列
* 5.16 自动（局部）变量的底层实现
* 5.17 参数的底层实现
* 5.17.1 在寄存器中传递参数
* 5.17.2 在代码流中传递参数
* 5.17.3 在堆栈中传递参数
* 5.18 过程指针
* 5.19 过程参数
* 5.20 无类型的引用参数
* 5.21 管理大型程序
* 5.22 #INCLUDE伪指令
* 5.23 忽略重复的#INCLUDE操作
* 5.24 单元与EXTERNAL伪指令
* 5.24.1 伪指令EXTERNAL的行为
* 5.24.2 HLA中的头文件
* 5.25 命名空间的污染
* 5.26 更多信息

## 第6章 算术运算

* 6.1 本章概述
* 6.2 80x86的整数运算指令
* 6.2.1 MUL和IMUL指令
* 6.2.2 DIV和IDIV指令
* 6.2.3 CMP指令
* 6.2.4 SETcc指令
* 6.2.5 TEST指令
* 6.3 算术表达式
* 6.3.1 简单赋值语句
* 6.3.2 简单表达式
* 6.3.3 复杂表达式
* 6.3.4 可交换运算符
* 6.4 逻辑（布尔）表达式
* 6.5 机器特征与运算技巧
* 6.5.1 不使用MUL、IMUL或INTMUL的乘法
* 6.5.2 不使用DIV或IDIV的除法
* 6.5.3 使用AND实现摸N计数器
* 6.5.4 疏忽使用机器特性
* 6.6 浮点运算
* 6.6.1 FPU寄存器
* 6.6.2 FPU的数据类型
* 6.6.3 FPU的指令集
* 6.6.4 FPU的数据转移指令
* 6.6.5 换算指令
* 6.6.6 算术运算指令
* 6.6.7 比较指令
* 6.6.8 常量指令
* 6.6.9 超越指令
* 6.6.10 其他指令
* 6.6.11 整数操作
* 6.7 浮点表达式到汇编语言的转换
* 6.7.1 算术表达式到后缀表示法的转换
* 6.7.2 把后缀表达式转换成汇编语言
* 6.8 HLA标准库对浮点算术运算的支持
* 6.8.1 函数stdin.getf和fileio.getf
* 6.8.2 HLA数学库中的三角函数
* 6.8.3 HLA数学库中的指数函数和对数函数

## 第7章 低级控制结构

* 7.1 本章概述
* 7.2 低级控制结构
* 7.3 语句标号
* 7.4 无条件控制转移（JMP）
* 7.5 条件跳转指令
* 7.6 “中级”控制结构：JT和JF
* 7.7 使用汇编语言实现通用控制结构
* 7.8 选择
* 7.8.1 IF..THEN..ELSE序列
* 7.8.2 将HLA的IF语句翻译成纯汇编语言语句
* 7.8.3 使用完全布尔求值实现复杂的IF语句
* 7.8.4 “短路”布尔求值
* 7.8.5 “短路”布尔求值与完全布尔求值
* 7.8.6 汇编语言中IF语句的高效实现
* 7.8.7 SWITCH/CASE语句
* 7.9 状态机和间接跳转
* 7.10 “面条式”代码
* 7.11 循环
* 7.11.1 WHILE循环
* 7.11.2 REPEAT..UNTIL循环
* 7.11.3 FOREVER..ENDFOR循环
* 7.11.4 FOR循环
* 7.11.5 BREAK和CONTINUE语句
* 7.11.6 寄存器的使用与循环
* 7.12 性能提高
* 7.12.1 将结束条件判断放在循环结尾
* 7.12.2 反向执行循环
* 7.12.3 循环不变计算
* 7.12.4 循环展开
* 7.12.5 归纳变量
* 7.13 HLA中的混合控制结构
* 7.14 更多信息

## 第8章 文件

* 8.1 本章概述
* 8.2 文件组织
* 8.2.1 作为记录列表的文件
* 8.2.2 二进制文件与文本文件的比较
* 8.3 顺序文件
* 8.4 随机访问文件
* 8.5 ISAM文件
* 8.6 截断文件
* 8.7 更多信息

## 第9章 高级算术运算

* 9.1 本章概述
* 9.2 多精度操作
* 9.2.1 扩充进度操作的HLA标准库支持
* 9.2.2 多精度加法操作
* 9.2.3 多精度减法操作
* 9.2.4 扩充精度比较操作
* 9.2.5 扩充精度乘法操作
* 9.2.6 扩充精度除法操作
* 9.2.7 扩充精度NEG操作
* 9.2.8 扩充精度AND操作
* 9.2.9 扩充精度OR操作
* 9.2.10 扩充精度XOR操作
* 9.2.11 扩充精度NOT操作
* 9.2.12 扩充精度移位操作
* 9.2.13 扩充精度循环操作
* 9.2.14 扩充精度I/O
* 9.3 对不同长度的操作数进行操作
* 9.4 十进制算术运算
* 9.4.1 文字BCD常量
* 9.4.2 80x86的DAA指令和DAS指令
* 9.4.3 80x86 AAA、AAS、AAM和AAD指令
* 9.4.4 使用FPU的压缩十进制算术操作
* 9.5 表
* 9.5.1 通过表查找进行函数计算
* 9.5.2 域调节
* 9.5.3 产生表
* 9.5.4 表查找的性能
* 9.6 更多信息

## 第10章 宏与HLA编译时语言

* 10.1 本章概述
* 10.2 编译时语言
* 10.3 #PRINT和#ERROR语句
* 10.4 编译时常量和变量
* 10.5 编译时表达式和操作符
* 10.6 编译时函数
* 10.6.1 类型转换编译时函数
* 10.6.2 数字编译时函数
* 10.6.3 字符分类编译时函数
* 10.6.4 编译时字符串函数
* 10.6.5 编译时模式匹配函数
* 10.6.6 编译时符号信息
* 10.6.7 其他编译时函数
* 10.6.8 编译时TEXT对象的类型转换
* 10.7 条件编译（编译时决定）
* 10.8 重复编译（编译时循环）
* 10.9 宏（编译时过程）
* 10.9.1 标准宏
* 10.9.2 宏的参数
* 10.9.3 宏中的局部符号
* 10.9.4 作为编译时过程的宏
* 10.9.5 使用宏模拟函数重载
* 10.10 编写编译时“程序”
* 10.10.1 在编译时构造数据表
* 10.10.2 循环展开
* 10.11 在不同的源文件中使用宏
* 10.12 更多信息

## 第11章 位操作

* 11.1 本章概述
* 11.2 位数据
* 11.3 伪操作指令
* 11.4 作为位累加器的进位标志位
* 11.5 位串的压缩与解压缩
* 11.6 接合位组与分布位串
* 11.7 压缩的位串数组
* 11.8 搜索位
* 11.9 位的计数
* 11.10 倒置位串
* 11.11 合并位串
* 11.12 提取位串
* 11.13 搜索位模式
* 11.14 HLA标准库的位模块
* 11.15 更多信息

## 第12章 字符串指令

* 12.1 本章概述
* 12.2 80x86字符串指令
* 12.2.1 字符串指令的操作过程
* 12.2.2 REP/REPE/REPZ和REPNZ/REPNE前缀
* 12.2.3 方向标志位
* 12.2.4 MOVS指令
* 12.2.5 CMPS指令
* 12.2.6 SCAS指令
* 12.2.7 STOS指令
* 12.2.8 LODS指令
* 12.2.9 从LODS和STOS构建复杂的字符串函数
* 12.3 80x86字符串指令的性能
* 12.4 更多信息

## 第13章 MMX指令集

* 13.1 本章概述
* 13.2 判断CPU是否支持MMX指令集
* 13.3 MMX编程环境
* 13.3.1 MMX寄存器
* 13.3.2 MMX数据类型
* 13.4 设计MMX指令集的目的
* 13.5 饱和算法和回转模式
* 13.6 MMX指令操作数
* 13.7 MMX技术指令
* 13.7.1 MMX数据传递指令
* 13.7.2 MMX转换指令
* 13.7.3 MMX压缩算术指令
* 13.7.4 MMX逻辑指令
* 13.7.5 MMX比较指令
* 13.7.6 MMX移位指令
* 13.7.7 EMMS指令
* 13.7.8 MMX编程方案
* 13.7.9 更多信息

## 第14章 类与对象

* 14.1 本章概述
* 14.2 通用原则
* 14.3 HLA中的类
* 14.4 对象
* 14.5 继承
* 14.6 重载
* 14.7 虚拟方法与静态过程
* 14.8 编写类方法和过程
* 14.9 对象实现
* 14.9.1 虚拟方法表
* 14.9.2 带继承的对象表达式
* 14.10 构造函数和对象初始化
* 14.10.1 构造函数中的动态对象分配
* 14.10.2 构造函数和继承
* 14.10.3 构造函数的参数和过程重载
* 14.11 析构函数
* 14.12 HLA的"_initialize_"和"_finalize_"字符串
* 14.13 抽象方法
* 14.14 运行时类型信息（RTTI）
* 14.15 调用基类的方法
* 14.16 更多信息

## 第15章 混合语言编程

* 15.1 本章概述
* 15.2 在同一程序中混合使用HLA和MASM/Gas代码
* 15.2.1 在同一程序中混合使用HLA和MASM/Gas代码
* 15.2.2 链接MASM/Gas汇编模块和HLA模块
* 15.3 使用Delphi/Kylix和HLA编程
* 15.3.1 链接HLA模块与Delphi/Kylix程序
* 15.3.2 寄存器保存
* 15.3.3 函数的结果
* 15.3.4 调用惯例
* 15.3.5 Kylix中的值传递、引用传递、CONST参数和OUT参数
* 15.3.6 Delphi/Kylix和HLA之间的标量数据类型
* 15.3.7 在Delphi/Kylix和HLA代码之间传递字符串数据
* 15.3.8 在HLA和Kylix之间传递记录数据
* 15.3.9 在Delphi/Kylix和HLA代码之间传递集和数据
* 15.3.10 在Delphi/Kylix和HLA代码之间传递数组数据
* 15.3.11 从HLA代码中引用Delphi/Kylix对象
* 15.4 使用C/C++和HLA编程
* 15.4.1 链接HLA模块和C/C++程序
* 15.4.2 寄存器保存
* 15.4.3 函数结果
* 15.4.4 调用惯例
* 15.4.5 C/C++中的值传递和引用传递
* 15.4.6 C/C++中和HLA之间的标量数据类型一致性
* 15.4.7 在C/C++和HLA代码之间传递字符串数据
* 15.4.8 在HLA和C/C++之间传递记录/结构数据
* 15.4.9 在HLA和C/C++之间传递数组数据
* 15.5 更多信息

* 附录A ASCII字符集
* 附录B 80x86指令集
